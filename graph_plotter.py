"""
Interactive Graph Plotter Application

A Python application for plotting mathematical functions and parametric equations.
"""

import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

# TODO's:
#
# Most of this code was generated by Cursor's default AI link, so there are some glaring mistakes and bugs.
# The initial code didn't even do anything - turned out that the initial size and x/y position of the main window was invalid,
# so who knows what the Python engine was doing with it... I took out the dynamic sizing/centering, and just hardcoded the intial
# size and position to get at least the equation input window to display.
#
# Here are some of the things that need fixing and some stuff I want to add:
#
# - need to correct the dialog size calculation
# - get rid of the initial hidden root window (so in the main function, you don't need to write "dialog.dialog" to access the equation input window)
# - hide the input box labels, instead of just the input boxes, when switching equation types
# - add the ability to recognize that a number next to a variable means "number * variable" (e.q. "2x = 2*x")
#       -parse the input equation and replace all numbers that are immediately followed by a variable with the "<number>*<variable>"
# - add the ability to change the graph window's x and y scales
# - add the ability to move up, down, left and right in the graph window
# - add auto-scaling of the graph window
# - add zoom-in and zoom-out functionality to the graph window

class EquationInputDialog:
    def __init__(self, parent):
        self.parent = parent
        self.result = None

        # Create the dialog window
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Graph Plotter - Equation Input")
        self.dialog.geometry("600x400")
        #self.dialog.resizable(False, False)

        # Center the dialog on screen
        # self.dialog.transient(parent)
        self.dialog.grab_set()

        # Make dialog modal
        self.dialog.protocol("WM_DELETE_WINDOW", self.on_exit)

        # Variables
        self.equation_type = tk.StringVar(value="y = f(x)")
        self.y_equation = tk.StringVar()
        self.x_parametric = tk.StringVar()
        self.y_parametric = tk.StringVar()

        self.create_widgets()
        self.update_visibility()

        # Center dialog on screen
        self.center_dialog()
        # self.dialog.geometry("699x400")
        # self.result = {}

    # TODO: need to correct this function - AI doesn't understand that the initial width and height of the dialog is 1x1 pixels, so its calculations won't work
    def center_dialog(self):
        """Center the dialog on the screen"""
        self.dialog.update_idletasks()
        width = self.dialog.winfo_width()
        height = self.dialog.winfo_height()
        x = (self.dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (self.dialog.winfo_screenheight() // 2) - (height // 2)
        # self.dialog.geometry(f"{width}x{height}+{x}+{y}")
        # self.dialog.geometry("600x400")

    def create_widgets(self):
        """Create all the widgets for the dialog"""
        # Main frame
        main_frame = ttk.Frame(self.dialog, padding="20")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Configure grid weights
        self.dialog.columnconfigure(0, weight=1)
        self.dialog.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)

        # Title
        title_label = ttk.Label(
            main_frame, text = "Graph Plotter", font = ("Arial", 16, "bold"))
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))

        # Equation type selection
        ttk.Label(main_frame, text="Equation type:").grid(
            row = 1, column = 0, sticky = tk.W, pady = 5)
        equation_combo = ttk.Combobox(main_frame, textvariable=self.equation_type,
                                      values = ["y = f(x)", "Parametric"], state = "readonly")
        equation_combo.grid(row=1, column=1, sticky=(
            tk.W, tk.E), pady=5, padx=(10, 0))
        equation_combo.bind("<<ComboboxSelected>>",
                            self.on_equation_type_change)

        # y = f(x) equation input
        ttk.Label(main_frame, text="y =").grid(
            row=2, column=0, sticky=tk.W, pady=5)
        self.y_entry = ttk.Entry(
            main_frame, textvariable=self.y_equation, width=30)
        self.y_entry.grid(row=2, column=1, sticky=(
            tk.W, tk.E), pady=5, padx=(10, 0))

        # Parametric equations
        ttk.Label(main_frame, text="x(t) =").grid(
            row=3, column=0, sticky=tk.W, pady=5)
        self.x_parametric_entry = ttk.Entry(
            main_frame, textvariable=self.x_parametric, width=30)
        self.x_parametric_entry.grid(
            row=3, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))

        ttk.Label(main_frame, text="y(t) =").grid(
            row=4, column=0, sticky=tk.W, pady=5)
        self.y_parametric_entry = ttk.Entry(
            main_frame, textvariable=self.y_parametric, width=30)
        self.y_parametric_entry.grid(
            row=4, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))

        # Example text
        example_frame = ttk.Frame(main_frame)
        example_frame.grid(row=5, column=0, columnspan=2,
                           pady=20, sticky=(tk.W, tk.E))
        example_frame.columnconfigure(0, weight=1)

        example_label = ttk.Label(
            example_frame, text="Examples:", font=("Arial", 10, "bold"))
        example_label.grid(row=0, column=0, sticky=tk.W)

        y_example = ttk.Label(
            example_frame, text="y = f(x): x**2, sin(x), exp(x)")
        y_example.grid(row=1, column=0, sticky=tk.W, pady=2)

        param_example = ttk.Label(
            example_frame, text="Parametric: x(t) = cos(t), y(t) = sin(t)")
        param_example.grid(row=2, column=0, sticky=tk.W, pady=2)

        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=6, column=0, columnspan=2, pady=20)

        ok_button = ttk.Button(button_frame, text="OK", command=self.on_ok)
        ok_button.pack(side=tk.LEFT, padx=(0, 10))

        exit_button = ttk.Button(
            button_frame, text="Exit", command=self.on_exit)
        exit_button.pack(side=tk.LEFT)

    def on_equation_type_change(self, event=None):
        """Handle equation type change"""
        self.update_visibility()

    def update_visibility(self):
        """Update visibility of equation input fields based on equation type"""
        if self.equation_type.get() == "y = f(x)":
            # Show y = f(x) input, hide parametric inputs
            self.y_entry.grid()
            self.x_parametric_entry.grid_remove()
            self.y_parametric_entry.grid_remove()
        else:
            # Show parametric inputs, hide y = f(x) input
            self.y_entry.grid_remove()
            self.x_parametric_entry.grid()
            self.y_parametric_entry.grid()

    def on_ok(self):
        """Handle OK button click"""
        equation_type = self.equation_type.get()

        if equation_type == "y = f(x)":
            if not self.y_equation.get().strip():
                messagebox.showerror(
                    "Error", "Please enter an equation for y = f(x)")
                return
            self.result = {
                'type': 'y=f(x)',
                'equation': self.y_equation.get().strip()
            }
        else:  # Parametric
            if not self.x_parametric.get().strip() or not self.y_parametric.get().strip():
                messagebox.showerror(
                    "Error", "Please enter both x(t) and y(t) equations")
                return
            self.result = {
                'type': 'parametric',
                'x_equation': self.x_parametric.get().strip(),
                'y_equation': self.y_parametric.get().strip()
            }

        self.dialog.destroy()

    def on_exit(self):
        """Handle Exit button click"""
        self.result = None
        self.dialog.destroy()

    def show(self):
        """Show the dialog and return the result"""
        # self.dialog.geometry("600x400")
        self.dialog.wait_window()
        return self.result


class GraphWindow:
    def __init__(self, parent, equation_data):
        self.parent = parent
        self.equation_data = equation_data

        # Create the main window
        self.window = tk.Toplevel(parent)
        self.window.title("Graph Plotter - Graph Display")
        self.window.geometry("800x600")
        self.window.minsize(600, 400)

        # Configure window
        self.window.protocol("WM_DELETE_WINDOW", self.on_close)

        self.create_widgets()
        self.plot_equation()

    def create_widgets(self):
        """Create the matplotlib figure and canvas"""
        # Create matplotlib figure
        self.fig, self.ax = plt.subplots(figsize=(10, 8))
        self.fig.patch.set_facecolor('#f0f0f0')

        # Create canvas
        self.canvas = FigureCanvasTkAgg(self.fig, self.window)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

    def plot_equation(self):
        """Plot the equation based on the equation data"""
        try:
            if self.equation_data['type'] == 'y=f(x)':
                self.plot_y_function()
            else:
                self.plot_parametric()
        except Exception as e:
            messagebox.showerror(
                "Plotting Error", f"Error plotting equation: {str(e)}")

    def plot_y_function(self):
        """Plot y = f(x) function"""
        equation = self.equation_data['equation']

        # Create x values
        x = np.linspace(-10, 10, 1000)

        # Convert equation to numpy-compatible function
        y = self.evaluate_equation(equation, x)

        # Clear previous plot
        self.ax.clear()

        # Plot the function
        self.ax.plot(x, y, 'b-', linewidth=2, label=equation)

        # Set up the plot
        self.setup_plot(f"y = {equation}")

    def plot_parametric(self):
        """Plot parametric equations"""
        x_equation = self.equation_data['x_equation']
        y_equation = self.equation_data['y_equation']

        # Create t values
        t = np.linspace(0, 4*np.pi, 1000)

        # Evaluate parametric equations
        x = self.evaluate_equation(x_equation, t)
        y = self.evaluate_equation(y_equation, t)

        # Clear previous plot
        self.ax.clear()

        # Plot the parametric curve
        self.ax.plot(x, y, 'r-', linewidth=2,
                     label=f"x(t)={x_equation}, y(t)={y_equation}")

        # Set up the plot
        self.setup_plot(f"x(t) = {x_equation}, y(t) = {y_equation}")

    def evaluate_equation(self, equation, x):
        """Safely evaluate a mathematical equation"""
        # Replace common mathematical functions
        equation = equation.replace('^', '**')
        equation = equation.replace('exp', 'np.exp')
        equation = equation.replace('sin', 'np.sin')
        equation = equation.replace('cos', 'np.cos')
        equation = equation.replace('tan', 'np.tan')
        equation = equation.replace('log', 'np.log')
        equation = equation.replace('sqrt', 'np.sqrt')
        equation = equation.replace('abs', 'np.abs')

        # Create a safe namespace
        namespace = {
            'x': x,
            't': x,  # For parametric equations, t is the parameter
            'np': np,
            'pi': np.pi,
            'e': np.e
        }

        # Evaluate the equation
        return eval(equation, {"__builtins__": {}}, namespace)

    def setup_plot(self, title):
        """Set up the plot with proper formatting"""
        # Add grid
        self.ax.grid(True, alpha=0.3)

        # Add axes
        self.ax.axhline(y=0, color='k', linewidth=0.5)
        self.ax.axvline(x=0, color='k', linewidth=0.5)

        # Set labels
        self.ax.set_xlabel('x', fontsize=12)
        self.ax.set_ylabel('y', fontsize=12)
        self.ax.set_title(title, fontsize=14, fontweight='bold')

        # Set limits
        self.ax.set_xlim(-10, 10)
        self.ax.set_ylim(-10, 10)

        # Add legend
        self.ax.legend()

        # Refresh canvas
        self.canvas.draw()

    def on_close(self):
        """Handle window close"""
        self.window.destroy()


class GraphPlotterApp:
    def __init__(self):
        # Create root window (hidden)
        self.root = tk.Tk()
        self.root.withdraw()  # Hide the root window

        # Set application title
        self.root.title("Graph Plotter")

        # Start the application
        self.run()

    def run(self):
        """Main application loop"""
        while True:
            # Show equation input dialog
            dialog = EquationInputDialog(self.root)
            result = dialog.show()

            if result is None:
                # User clicked Exit
                break
            else:
                # User clicked OK, show graph window
                graph_window = GraphWindow(self.root, result)
                # Wait for graph window to close before showing dialog again
                graph_window.window.wait_window()

        # Clean up
        self.root.destroy()


def main():
    """Main entry point"""
    GraphPlotterApp()


if __name__ == "__main__":
    main()
